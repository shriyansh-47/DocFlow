const natural = require("natural");
const path = require("path");
const { NLP_CONFIDENCE_THRESHOLD } = require("../config");

// ═══════════════════════════════════════════════════════════════════════════════
// NLP-based Document Classifier
//
// Uses a Naive Bayes classifier trained on 196 sample statements across
// 3 categories: admissions, scholarship, internship.
//
// If the best category's confidence is below NLP_CONFIDENCE_THRESHOLD,
// the document is rejected as unclassifiable.
// ═══════════════════════════════════════════════════════════════════════════════

// Load the trained classifier (generated by scripts/trainClassifier.js)
let classifier = null;

function loadClassifier() {
  if (classifier) return classifier;

  return new Promise((resolve, reject) => {
    const modelPath = path.join(__dirname, "..", "data", "classifier.json");
    natural.BayesClassifier.load(modelPath, null, (err, loaded) => {
      if (err) return reject(err);
      classifier = loaded;
      resolve(classifier);
    });
  });
}

// Preload on module import
loadClassifier().catch((err) =>
  console.error("⚠ Failed to load NLP classifier:", err.message)
);

/**
 * Normalize raw probability values from the Bayes classifier to 0–1 confidence scores.
 * natural's BayesClassifier.getClassifications() returns actual probabilities (not log),
 * so we simply divide each by their sum.
 */
function normalize(classifications) {
  const sum = classifications.reduce((a, c) => a + c.value, 0);
  if (sum === 0) {
    // Fallback: equal distribution if all zeros
    const equal = 1 / classifications.length;
    return classifications.map((c) => ({ label: c.label, confidence: equal }));
  }
  return classifications.map((c) => ({
    label: c.label,
    confidence: c.value / sum,
  }));
}

/**
 * Classify a document using the trained NLP model.
 *
 * Returns the SAME shape as the old keyword-based classifier so
 * upload.js and other routes don't need any changes:
 *   { category, isValid, scores, bestScore, detected, missing, failReason? }
 */
async function classifyDocument(rawText) {
  const clf = await loadClassifier();
  const cleanText = rawText.toLowerCase().replace(/\s+/g, " ").trim();

  // Get raw classifications (log probabilities)
  const rawClassifications = clf.getClassifications(cleanText);

  // Normalize to 0–1 confidence using softmax
  const normalized = normalize(rawClassifications);

  // Build scores object { admissions: 0.85, scholarship: 0.10, internship: 0.05 }
  const scores = {};
  normalized.forEach((c) => {
    scores[c.label] = Math.round(c.confidence * 1000) / 1000; // 3 decimal places
  });

  // Best result
  const best = normalized[0];
  const bestScore = Math.round(best.confidence * 100); // percentage for display

  // Reject if classified as "other" (out-of-domain)
  if (best.label === "other") {
    // Find the best valid category for the error message
    const bestValid = normalized.find(
      (c) => c.label !== "other"
    );
    return {
      category: "none",
      isValid: false,
      scores,
      bestScore,
      detected: {},
      missing: [],
      failReason: `Document does not appear to be related to admissions, scholarship, or internship. The document was classified as general/unrelated content. Please upload a relevant document.`,
    };
  }

  // Confidence check — reject if the valid category confidence is too low
  if (best.confidence < NLP_CONFIDENCE_THRESHOLD) {
    return {
      category: "none",
      isValid: false,
      scores,
      bestScore,
      detected: {},
      missing: [],
      failReason: `Document could not be classified with sufficient confidence. Best match: "${best.label}" at ${bestScore}% (threshold: ${Math.round(NLP_CONFIDENCE_THRESHOLD * 100)}%). Please upload a document clearly related to admissions, scholarship, or internship.`,
    };
  }

  return {
    category: best.label,
    isValid: true,
    scores,
    bestScore,
    detected: { nlpCategory: best.label, nlpConfidence: best.confidence },
    missing: [],
  };
}

module.exports = { classifyDocument };

// ═══════════════════════════════════════════════════════════════════════════════
// Mandatory Field Validator
//
// Checks that the uploaded document contains required fields:
//   - Name of the applicant
//   - Date
//   - Subject line
//   - Roll number / Student ID
//   - Contact info (email or phone)
//
// Uses regex pattern matching on the raw text.
// ═══════════════════════════════════════════════════════════════════════════════

const MANDATORY_FIELDS = [
  {
    name: "Name",
    patterns: [
      /\bname\s*[:\-–—]\s*\S+/i,
      /\b(?:i\s*,?\s+|my\s+name\s+is\s+|undersigned\s*,?\s*)\S+/i,
      /\b(?:mr|mrs|ms|miss|dr|prof)\.?\s+[A-Z][a-z]+/i,
      /\bapplicant\s*[:\-–—]\s*\S+/i,
      /\bstudent\s+name\s*[:\-–—]\s*\S+/i,
      /\bfull\s+name\s*[:\-–—]\s*\S+/i,
    ],
  },
  {
    name: "Date",
    patterns: [
      /\bdate\s*[:\-–—]\s*\S+/i,
      /\b\d{1,2}[\/.\\-]\d{1,2}[\/.\\-]\d{2,4}\b/,
      /\b\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s*,?\s*\d{2,4}\b/i,
      /\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{1,2}\s*,?\s*\d{2,4}\b/i,
      /\bdated?\s*[:\-–—]?\s*\d/i,
    ],
  },
  {
    name: "Subject",
    patterns: [
      /\bsubject\s*[:\-–—]\s*\S+/i,
      /\bsub\s*[:\-–—]\s*\S+/i,
      /\bre\s*[:\-–—]\s*\S+/i,
      /\bregarding\s*[:\-–—]\s*\S+/i,
      /\btopic\s*[:\-–—]\s*\S+/i,
    ],
  },
  {
    name: "Roll Number / Student ID",
    patterns: [
      /\b(?:roll|reg|registration|student)\s*(?:no|number|id|#)\s*[:\-–—]?\s*\S+/i,
      /\b(?:id|enrollment)\s*(?:no|number|#)\s*[:\-–—]?\s*\S+/i,
      /\b[A-Z]{2,5}[\-\/]?\d{2,4}[\-\/]?\d{2,6}\b/,
      /\broll\s*[:\-–—]\s*\S+/i,
    ],
  },
  {
    name: "Contact Info (Email or Phone)",
    patterns: [
      /\b[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}\b/,
      /\b(?:phone|mobile|contact|tel|cell)\s*(?:no|number|#)?\s*[:\-–—]?\s*[\d\s\-+()]{7,}/i,
      /\b(?:\+?\d{1,3}[\s\-]?)?\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{4}\b/,
      /\b\d{10,12}\b/,
    ],
  },
];

/**
 * Check the document text for mandatory fields.
 * Returns { valid: true } or { valid: false, missing: [...fieldNames] }
 */
function validateMandatoryFields(rawText) {
  const missing = [];

  for (const field of MANDATORY_FIELDS) {
    const found = field.patterns.some((pattern) => pattern.test(rawText));
    if (!found) {
      missing.push(field.name);
    }
  }

  return missing.length === 0
    ? { valid: true, missing: [] }
    : { valid: false, missing };
}

module.exports = { classifyDocument, validateMandatoryFields };
