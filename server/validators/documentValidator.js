const natural = require("natural");
const path = require("path");
const { NLP_CONFIDENCE_THRESHOLD } = require("../config");

// ═══════════════════════════════════════════════════════════════════════════════
// NLP-based Document Classifier
//
// Uses a Naive Bayes classifier trained on 196 sample statements across
// 3 categories: admissions, scholarship, internship.
//
// If the best category's confidence is below NLP_CONFIDENCE_THRESHOLD,
// the document is rejected as unclassifiable.
// ═══════════════════════════════════════════════════════════════════════════════

// Load the trained classifier (generated by scripts/trainClassifier.js)
let classifier = null;

function loadClassifier() {
  if (classifier) return classifier;

  return new Promise((resolve, reject) => {
    const modelPath = path.join(__dirname, "..", "data", "classifier.json");
    natural.BayesClassifier.load(modelPath, null, (err, loaded) => {
      if (err) return reject(err);
      classifier = loaded;
      resolve(classifier);
    });
  });
}

// Preload on module import
loadClassifier().catch((err) =>
  console.error("⚠ Failed to load NLP classifier:", err.message)
);

/**
 * Normalize raw probability values from the Bayes classifier to 0–1 confidence scores.
 * natural's BayesClassifier.getClassifications() returns actual probabilities (not log),
 * so we simply divide each by their sum.
 */
function normalize(classifications) {
  const sum = classifications.reduce((a, c) => a + c.value, 0);
  if (sum === 0) {
    // Fallback: equal distribution if all zeros
    const equal = 1 / classifications.length;
    return classifications.map((c) => ({ label: c.label, confidence: equal }));
  }
  return classifications.map((c) => ({
    label: c.label,
    confidence: c.value / sum,
  }));
}

/**
 * Classify a document using the trained NLP model.
 *
 * Returns the SAME shape as the old keyword-based classifier so
 * upload.js and other routes don't need any changes:
 *   { category, isValid, scores, bestScore, detected, missing, failReason? }
 */
async function classifyDocument(rawText) {
  const clf = await loadClassifier();
  const cleanText = rawText.toLowerCase().replace(/\s+/g, " ").trim();

  // Get raw classifications (log probabilities)
  const rawClassifications = clf.getClassifications(cleanText);

  // Normalize to 0–1 confidence using softmax
  const normalized = normalize(rawClassifications);

  // Build scores object { admissions: 0.85, scholarship: 0.10, internship: 0.05 }
  const scores = {};
  normalized.forEach((c) => {
    scores[c.label] = Math.round(c.confidence * 1000) / 1000; // 3 decimal places
  });

  // Best result
  const best = normalized[0];
  const bestScore = Math.round(best.confidence * 100); // percentage for display

  // Reject if classified as "other" (out-of-domain)
  if (best.label === "other") {
    // Find the best valid category for the error message
    const bestValid = normalized.find(
      (c) => c.label !== "other"
    );
    return {
      category: "none",
      isValid: false,
      scores,
      bestScore,
      detected: {},
      missing: [],
      failReason: `Document does not appear to be related to admissions, scholarship, or internship. The document was classified as general/unrelated content. Please upload a relevant document.`,
    };
  }

  // Confidence check — reject if the valid category confidence is too low
  if (best.confidence < NLP_CONFIDENCE_THRESHOLD) {
    return {
      category: "none",
      isValid: false,
      scores,
      bestScore,
      detected: {},
      missing: [],
      failReason: `Document could not be classified with sufficient confidence. Best match: "${best.label}" at ${bestScore}% (threshold: ${Math.round(NLP_CONFIDENCE_THRESHOLD * 100)}%). Please upload a document clearly related to admissions, scholarship, or internship.`,
    };
  }

  return {
    category: best.label,
    isValid: true,
    scores,
    bestScore,
    detected: { nlpCategory: best.label, nlpConfidence: best.confidence },
    missing: [],
  };
}

module.exports = { classifyDocument };
